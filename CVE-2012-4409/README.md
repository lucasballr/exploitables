# [CVE-2012-4409](https://nvd.nist.gov/vuln/detail/CVE-2012-4409)

### The vulnerability

This vulnerability is interesting to understand. The mcrypt utility is an old utility that was meant for encrypting and decrypting files. The
default functionality is to use the rijndael-128/cbc mode algorithm to encrypt any file with the password of your choosing. This functionality doesn't
really matter since the exploit is in the decryption functionality of the program. 

The vulnerability is specifically in the `check_file_head()` function that gets run in order to read a an encrypted file. The file head includes all
of the necessary information for the program to understand what mode the file is encrypted in and what algorithm it uses. The head of the file looks
something like this:
```
b'\x00m\x03@rijndael-128\x00\x20\x00cbc\x00mcrypt-sha1\x00'
```
The first 3 bytes must be `\x00\x03\x64` which is essentially the magic bytes for the mcrypt encrypted file format. Then the next section will have
the algorithm used for encryption followed by a `\x00`. Then a space followed by the mode of the algorithm. All of this is specified in the source
code and each section is parsed one-by-one using the `read_until_null` function which just reads from a file descriptor until it reaches a NULL byte.
At the end of this is special byte that will show up after the `mcrypt-sha1\x00`. This next section is specifying the length of the salt used during
encryption so the decryptor knows how much to read. The normal maximum length of a salt shouldn't ever hit more than 64 bytes, but the tmp_buf that
the program uses to read the salt into is 101 bytes. If there is a bounds checking for the salt size, this is fine, this is where the program goes
wrong. You can see here:
```c
fread(&sflag, 1, 1, fstream);
if (m_getbit(6, flags) == 1) { /* if the salt bit is set */
    if (m_getbit(0, sflag) != 0) { /* if the first bit is set */
        *salt_size = m_setbit(0, sflag, 0);
        if (*salt_size > 0) {
            fread(tmp_buf, 1, *salt_size,
                 fstream);
            memmove(salt, tmp_buf, *salt_size);
        }
    }
}
```
The salt size or `sflag` never gets bounds checked. This means that an attacker could create a malicious file that masquerades as an mcrypt encrypted
file, but has an extremely large sflag byte making the program read more bytes than the size of the tmp_buf. This would effectively overflow the
stack.


### The exploit

The exploit is relatively simple once you understand the functionality of the vulnerability. All you need to do is create a file that passes all the
checks and gets the program to the piece of code that I specified up above. The byte string that I put above works as a base, but you can honestly use
any string in between the null bytes. the next step is to add in one more byte to specify the sflag. I just put the largest byte `\xff`. Then you need
to fill the `tmp_buf` with 101 random bytes. The exploit adds a few more random bytes to accommodate for some extra variables. Then, in a normal
situation, the stack could be overwritten with `0xff-101` bytes allowing the attacker to overwrite the return address of the `check_file_head()`
function. This is exactly what I did, but with a few caveats: 
1. The return address was the only thing I was able to overwrite making it only viable to use something like a `one_gadget`.
2. None of the single jump-to locations would yeild beneficial results towards getting a shell.
Nonetheless, I went through with it. The exploit here will run any arbitrary piece of code in the binary making it entirely possible to pop a shell.


### Issues with the exploit

I had to use `-D_FORTIFY_SOURCE=0` in the makefile in order to disable the modern Fortify which wasn't applied when this vulnerability was found. I also had to disable the stack canary.

The original vuln I believe was found using 32-bit compilation. Making this updated version slightly different. This only allows for an 8-byte
overflow making it extremely difficult to actually exploit this program. Due to the old nature of this version of mcrypt, it appears as though a
full RCE exploit is not able to be made.

### What can be learned.

One of the problems with diving into older real world vulnerabilities is the dependency issue. Often, you can compile any program with the same
environment as the original vulnerablity. Once the vulnerability hits 10 years old, though, the viability gets a little harder. 10 years is about the
length of LTS support, so anything older than that has the chance of not being supported. This makes it hard to replicate these older
vulnerabilities. In this case, the program was originally exploited on a 32-bit machine with certain comiler flags to make it specifically vulnerable
to a full chain exploit. The modern-day version of this exploit is slightly more difficult to create, but still shows that this vulnerability was
critical. 

### Running the exploit.

This one is relatively simple. All you need to do is build the docker container with `docker build -t cve-2012-4409 .` and run it making sure to mount
the current directory: `docker run -it -v $(pwd):/tmp/ cve-2012-4409`. Then you can just run `mcrypt -d /tmp/some.nc` in order to run the exploit that
was created by e.py. If you want to play with the file and try different return addresses, you can modify the ./e.py python program and run it in the
directory. This will create a new some.nc file that can be used in the container.

### Further work

This exploit can be expanded upon taking advantage of 2 different exploit strategies: ROP, and base pointer poisoning. Since the capability of the
exploit is restricted to overwriting the return address, potentially the next logical step is to go after the parent function of `check_file_head()`.
Then building a ROP chain from that could send the program to a one_gadget with a higher chance of popping a shell.
