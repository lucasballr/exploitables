# [CVE-2022-3296](https://nvd.nist.gov/vuln/detail/CVE-2022-3296)

# Understanding the vulnerability

To understand this vulnerability, you have to understand how scripting is implemented into Vim. Essentially the way it works is either by typing `:`
in normal mode and typing out a command OR specifying a script with the `-S` option when launching the program. The vulnerability exists in either
implementation, but it is easier to use the `-S` capability which is more likely to be used by a bad actor.

This is a vulnerability in the `ex_finally` function in the `try/catch` functionality of Vim scripting. The `:try` command does exactly what a normal
try block would do: it attempts to run something, but if it doesn't work, it will `catch` the exception made by the program. An example of this would
be something like:
```vim
function! TryCatchExample()
    try
        execute 'edit /path/to/file'
    catch
        echo "Error opening file: " . v:exception
    finally
        echo "Performing cleanup actions"
    endtry
endfunction
```
If the file in the try block doesn't exist, the catch will be thrown and will show an exception. The issue comes when you try to start some loops and
conditionals within the try block and then call the finally keyword without ending the loops. Since these loops and conditionals don't have `end`
statements, they will cause an error. This would normally be handled by the try block and returned by the catch, but since the finally block is being
hit with no catch and no end for the opened conditionals, the try function runs into a problem unraveling the call stack and tries to dereference the
`-1` index. This essentially enables an attacker to manipulate memory around the cstack variable (which is just on the stack at the time of
modification).

# The exploit

The exploit is just a simple program that opens a try block and then does a bunch of if/for statements in between the try block and a finally block.
This will fill up the call stack do be unraveled during the ex_finally function. The script looks like this:
```vim
try
for         # for loop opening
0           # for loop value. doesn't matter what this is.
if          # first if block opening
endwhile    # This is required to break the infinite loop but keep the for block
if          # second if block opening
finally
```
This sequence of commands creates a dereference of the cstack at index -1. Since the call stack is technically able to be manipulated, the exploit
could add some malicious information or put memory values at the beginning of the call stack to modify the program internal memory. I can see that
happening when I add more `if` conditionals to this script. The address sanitizer runs into an infinite loop due to a faulty memory access. Since this
vulnerability doesn't indicate a guaranteed manipulation of the memory, this is where my work ends. With further exploration, it is theoretically
possible to manipulate the internal memory of the program to change the control flow.

# The patch

This was patched in the Sep 24, 2022 commit on github with a fundamental change to the cstack checking within the `ex_finally()` function. This
section was removed:
```c
if (!(cstack->cs_flags[cstack->cs_idx] & CSF_TRY))
{
    eap->errmsg = get_end_emsg(cstack);
    for (idx = cstack->cs_idx - 1; idx > 0; --idx)
    if (cstack->cs_flags[idx] & CSF_TRY)
        break;
    pending = CSTP_ERROR;
}
else
    idx = cstack->cs_idx;
```
and this replaced it:
```c
if (!(cstack->cs_flags[cstack->cs_idx] & CSF_TRY))
{
	eap->errmsg = get_end_emsg(cstack);
	pending = CSTP_ERROR;
}
```
The comment in there explains a little bit of the change. Basically instead of looping backward through the call stack, it just goes straight to the
error. This prevents the faulty unraveling of the stack.

# What we can learn from this

In the modern day, CVE's are graded based off the potential impact in the real world. Just because a CVE has a critical score does not mean that there
is a proven pop-a-shell chain. This is something that is important to understand in exploit writing for real-world exploits. 

# Running the exploit

Go into the `vulnerable/` directory that I have shown you and run `docker build -t cve-2022-3296 .` This will build the vulnerable version of vim.

Then you can run `docker run -it cve-2022-3296` to get into a shell for the container. This should pop you right into the directory of the vim binary.

Then you can run `./vim -u NONE -i NONE -n -m -X -Z -e -s -S /tmp/something` to see the sanitizer error. If you would like to look at the memory and
mess with the binary, just modify the bytes in the e.py and run ./e.py. You might have to run it outside of the container and copy the `something`
script in. Then run the program with `pwndbg --args ./vim -u NONE -i NONE -n -m -X -Z -e -s -S /tmp/something`.


