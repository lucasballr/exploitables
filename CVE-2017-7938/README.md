# [CVE-2017-7938](https://nvd.nist.gov/vuln/detail/CVE-2017-7938)

The vulnerability described here does not go much further than what is described on the NVD site. There is a simple buffer overflow vulnerability in
the program when the argv[1] is too long. This leads to a segfault due to an attempted dereference of the characters in the buffer. The issue is that
the program's default compilation options take that into account and prevent any real exploitation as a result of this buffer overflow. I will go into
deatail about the vulnerability though before tackling a separate vulnerability in the code.

# The Vulnerability

The vulnerability is a small buffer overflow that was found in the program likely by running valgrind against the program with different argv sizes.
The program's normal functionality takes the `argv[argc-1]` which is the last argument to the program and saves that value to the char `host_ip` and/or `host_name` variables. 
The value doesn't actually get bounds checked, so you can write as much as you want into the argv. This is shown by the line 152 of dmitry.c here:
```c
strcpy(host_ip, argv[argc - 1]);
```
This easily overflows the stack once the host_ip and host_name variable are overwritten. The issue with continuing this exploit path is that control
flow becomes hard to change. This is because a buffer that overwrites more than 8 bytes past those variables (roughly 145 bytes) will corrupt the
variables of functions later in the program causing an infinite read to an empty socket. To find out more information on this, you can take a look at
the `ip_string_search` function in the source code. In here is where the infinite read ends up.

Technically control flow was manipulated by the user input, but the more precise modification is much harder to achieve.

# The Second Vulnerability

The second vulnerability was found in the `get_nwhois()` function. The normal usage of this function is to resolve the host that has been specified by
the user input. Upon gathering this information, the program will use `printf()` to display the host that you have specified. The prinf call does not
include a specified format string allowing the user to exploit a format string vulnerability. This is what that looks like:
```
/* Print introduction to function */
memset(linebuff, '\0', sizeof(linebuff));
snprintf(linebuff, sizeof(linebuff), "\nGathered Inic-whois information for %s\n", fhost);
print_line(linebuff); ### VULNERABLE

memset(linebuff, '\0', sizeof(linebuff));
snprintf(linebuff, sizeof(linebuff), "---------------------------------\n");
print_line(linebuff); ### VULNERABLE
```
After some testing, I was able to get content from the stack by using the %p format string. Since there are no restrictions to the characters that you
put in argv, a specially crafted payload could overwrite arbitrary locations in memory. The main restriction is that the argv does not allow for null
bytes making it much more difficult to conduct full arbitrary write. 

# The Exploit

The exploit that I decided to make is a an stack-offset format string arbitrary write. Essentially what I'm dong is corrupting the saved EBP of the
`get_nwhois()` function. This, in turn corrupts the stack modifying the return value of the main function. I'll show some snippets from GDB to explain
what I'm talking about. This is what it looked like before:
![before](./img/before.png)
And this is what it looked like afterward.
![after](./img/after.png)

As a result. I was able to stack pivot to any location I wanted allowing for a much more fine grained control flow modification.

# The patch

The solution to both of these problems was relatively simple. For the buffer overflow they just replaced the `strcpy()` function (which is known for
being very vulnerable) with the more secure `strncpy()` which copies a only the allowed size for the variable. This is what that looks like.
```c
strncpy(host_name, argv[argc - 1], MAXNAMELEN - 1);
host_name[MAXNAMELEN - 1] = '\0';
```
The solution to the format string vulnerability was even more simple: Just add a format string to the printf statement.
```
print_line("%s", linebuff);
```

# What can we learn from this

The main thing to be learned from this situation is understanding how this could be exploited in the real world. One option could be that the user has
the dmitry program on their computer and they get manipulated into running a maliciously formed program that then calls dmitry with these bad
arguments. The other option could be a remote server that runs dmitry as a service. In this case, the user could input a malicious host string causing
either a denial of service or a full RCE on the remote machine.

When it comes to exploit creation, fully understanding the amount of control you have over the program is important in order to fully manipulate the
control flow. Just simply knowing there is a format string vulnerability is not enough. You need to actually dive into the memory of the program to
know what you are doing to the memory. This is much like a ctf challenge and this is definitely something you could see in a CTF which makes it a
perfect example of how lots of real world vulnerabilities can be exploited the same way a CTF challenge can.

# Running the exploit

I decided not to show the patched version since the patch is pretty simple, but you can run this on your base system as long as you have pwntools
installed. Since this is a really simple exploit, there is not much need for a more complex environment. In order to continue the exploit to
potentially escalate privileges, you can build the container with docker and mess with the internals there.


